# 01-02 - setState連續呼叫這麼多次，怎麼只作用一次？

## 🎯 題目：React 的批次更新與閉包陷阱

### 問題描述
連續呼叫 5 次 `setCount(count + 1)`，為什麼最終只增加了 1 而不是 5？

### 🔴 問題程式碼
```jsx
const [count, setCount] = useState(0)

const handleMultipleUpdates = () => {
  setCount(count + 1)  // count = 0, 設定為 1
  setCount(count + 1)  // count = 0, 設定為 1 (還是舊值！)
  setCount(count + 1)  // count = 0, 設定為 1 (還是舊值！)
  setCount(count + 1)  // count = 0, 設定為 1 (還是舊值！)
  setCount(count + 1)  // count = 0, 設定為 1 (還是舊值！)
  console.log(count)   // 還是 0！
}
```

**檔案位置：** [`problem/App.jsx`](problem/App.jsx)

### 🟢 解決方案

#### ✅ 方法1：使用函數式更新（推薦）
```jsx
const handleMultipleUpdates = () => {
  setCount(prevCount => prevCount + 1)  // 基於前一個值
  setCount(prevCount => prevCount + 1)  // 基於前一個值
  setCount(prevCount => prevCount + 1)  // 基於前一個值
  setCount(prevCount => prevCount + 1)  // 基於前一個值
  setCount(prevCount => prevCount + 1)  // 基於前一個值
  // 最終結果：5
}
```

#### ✅ 方法2：一次性計算（最佳解法）
```jsx
const handleMultipleUpdates = () => {
  setCount(count + 5)  // 直接加5
}
```

**檔案位置：** [`solution/App.jsx`](solution/App.jsx)

### 🧠 原理解釋

#### **問題1：閉包陷阱**
```jsx
const [count, setCount] = useState(0)  // count = 0

const handleClick = () => {
  // 這個函數閉包捕獲了當前的 count 值 (0)
  setCount(count + 1)  // 實際上是 setCount(0 + 1)
  setCount(count + 1)  // 實際上是 setCount(0 + 1)
  setCount(count + 1)  // 實際上是 setCount(0 + 1)
  // 最後一個會覆蓋前面的，結果還是 1
}
```

#### **問題2：React 的批次更新**
- React 會將同一個事件處理器中的多個 setState 批次處理
- 相同的狀態更新會被合併，後面的覆蓋前面的

#### **解決原理：函數式更新**
```jsx
setCount(prevCount => prevCount + 1)
// React 內部會這樣執行：
// 第1次：prevCount = 0 → 返回 1
// 第2次：prevCount = 1 → 返回 2  
// 第3次：prevCount = 2 → 返回 3
// ...依此類推
```

### 📚 學習重點
- **閉包與狀態**：函數閉包會捕獲當前的狀態值
- **批次更新**：React 會合併同一事件中的多個 setState
- **函數式更新**：`setState(prev => newValue)` 確保基於最新值更新
- **useState 的異步性**：setState 後立即讀取狀態還是舊值

### 🚀 測試步驟
1. 複製 `problem/App.jsx` 到主專案的 `src/App.jsx`
2. 點擊 "+5" 按鈕，觀察只增加了 1
3. 打開開發者工具查看 console 輸出
4. 複製 `solution/App.jsx` 到主專案的 `src/App.jsx`
5. 測試不同的解決方案，觀察差異

### 💡 實用技巧
```jsx
// ❌ 錯誤：基於舊值的多次更新
setCount(count + 1)
setCount(count + 1)

// ✅ 正確：函數式更新
setCount(prev => prev + 1)
setCount(prev => prev + 1)

// ✅ 更好：一次性計算
setCount(count + 2)

// ✅ 複雜邏輯：可以在函數中處理
setCount(prev => {
  const newValue = prev + someComplexCalculation()
  console.log('更新為:', newValue)
  return newValue
})
```
