# 01-02 - setState 連續呼叫這麼多次，怎麼只作用一次？

## 🎯 題目：React 的批次更新機制

### 問題描述

連續呼叫多次 setState，為什麼最終只更新了一次？

### 🔴 問題程式碼

```jsx
const [count, setCount] = useState(0);

const handleMultipleUpdates = () => {
  setCount(count + 1); // count = 0, 設定為 1
  setCount(count + 1); // count = 0, 設定為 1 (還是舊值！)
  setCount(count + 1); // count = 0, 設定為 1 (還是舊值！)
  console.log(count); // 還是 0！
};
```

**檔案位置：** `problem/App.jsx` (待建立)

### 🟢 解決方案

#### 方法 1：使用函數式更新

```jsx
const handleMultipleUpdates = () => {
  setCount((prevCount) => prevCount + 1); // 基於前一個值
  setCount((prevCount) => prevCount + 1); // 基於前一個值
  setCount((prevCount) => prevCount + 1); // 基於前一個值
};
```

#### 方法 2：一次性計算

```jsx
const handleMultipleUpdates = () => {
  setCount(count + 3); // 直接加3
};
```

**檔案位置：** `solution/App.jsx` (待建立)

### 🧠 原理解釋

1. **閉包問題**：每個 `setCount(count + 1)` 中的 `count` 都是當時的值 (0)
2. **批次更新**：React 會將多個狀態更新批次處理
3. **函數式更新**：`prevCount => prevCount + 1` 確保基於最新值更新

### 📚 學習重點

- React 的批次更新機制
- 閉包與狀態更新
- 函數式更新的重要性
- useState 的異步特性

### 🚀 測試步驟

1. 建立問題版本，觀察連續點擊後的結果
2. 使用 console.log 觀察狀態值
3. 實作函數式更新解決方案
4. 比較兩種方法的差異
