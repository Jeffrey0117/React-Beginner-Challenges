# 解答：setState 連續呼叫問題

## 🟢 解決方案

### ✅ 方法1：使用函數式更新（推薦）

```jsx
const handleMultipleUpdates = () => {
  setCount(prevCount => prevCount + 1)  // 基於前一個值
  setCount(prevCount => prevCount + 1)  // 基於前一個值
  setCount(prevCount => prevCount + 1)  // 基於前一個值
  setCount(prevCount => prevCount + 1)  // 基於前一個值
  setCount(prevCount => prevCount + 1)  // 基於前一個值
  // 最終結果：5
}
```

### ✅ 方法2：一次性計算（最佳解法）

```jsx
const handleMultipleUpdates = () => {
  setCount(count + 5)  // 直接加5
}
```

## 🧠 原理解釋

### **問題1：閉包陷阱**

```jsx
const [count, setCount] = useState(0)  // count = 0

const handleClick = () => {
  // 這個函數閉包捕獲了當前的 count 值 (0)
  setCount(count + 1)  // 實際上是 setCount(0 + 1)
  setCount(count + 1)  // 實際上是 setCount(0 + 1)
  setCount(count + 1)  // 實際上是 setCount(0 + 1)
  // 最後一個會覆蓋前面的，結果還是 1
}
```

### **問題2：React 的批次更新**

- React 會將同一個事件處理器中的多個 setState 批次處理
- 相同的狀態更新會被合併，後面的覆蓋前面的

### **解決原理：函數式更新**

```jsx
setCount(prevCount => prevCount + 1)
// React 內部會這樣執行：
// 第1次：prevCount = 0 → 返回 1
// 第2次：prevCount = 1 → 返回 2  
// 第3次：prevCount = 2 → 返回 3
// ...依此類推
```

## 📚 核心概念

### **1. JavaScript 閉包**
```jsx
function Counter() {
  const [count, setCount] = useState(0)
  
  const handleClick = () => {
    // 這裡的 count 是閉包捕獲的值，不會自動更新
    console.log('閉包中的 count:', count)  // 永遠是點擊時的值
  }
  
  return <button onClick={handleClick}>Count: {count}</button>
}
```

### **2. React 批次更新**
```jsx
// React 18 之前
function handleClick() {
  setCount(count + 1)  // 批次更新開始
  setName('John')      // 加入批次
  setAge(25)           // 加入批次
  // 批次更新結束，統一重新渲染
}

// 結果：只重新渲染一次，而不是三次
```

### **3. 函數式更新的優勢**
```jsx
// ❌ 問題：基於舊值
const increment5Times = () => {
  const currentCount = count  // 0
  setCount(currentCount + 1)  // 設定為 1
  setCount(currentCount + 1)  // 設定為 1 (覆蓋)
  setCount(currentCount + 1)  // 設定為 1 (覆蓋)
}

// ✅ 解決：基於最新值
const increment5Times = () => {
  setCount(prev => prev + 1)  // 0 + 1 = 1
  setCount(prev => prev + 1)  // 1 + 1 = 2
  setCount(prev => prev + 1)  // 2 + 1 = 3
}
```

## 💡 實用技巧

### **複雜狀態更新**
```jsx
// ✅ 在函數式更新中處理複雜邏輯
setCount(prevCount => {
  const newValue = prevCount + calculateIncrement()
  
  // 可以添加條件判斷
  if (newValue > 100) {
    return 100  // 限制最大值
  }
  
  // 可以添加日誌
  console.log(`Count updated from ${prevCount} to ${newValue}`)
  
  return newValue
})
```

### **多個狀態同時更新**
```jsx
// 如果需要基於當前狀態更新多個狀態
const handleComplexUpdate = () => {
  setCount(prevCount => {
    const newCount = prevCount + 1
    
    // 基於新的 count 值更新其他狀態
    setProgress((newCount / maxCount) * 100)
    
    return newCount
  })
}
```

## 🔍 調試技巧

```jsx
// 使用 console.log 追蹤更新過程
setCount(prevCount => {
  console.log('Previous count:', prevCount)
  const newCount = prevCount + 1
  console.log('New count:', newCount)
  return newCount
})
```

---

**記住：當需要基於當前狀態計算新狀態時，永遠使用函數式更新！** 🎯
