# 解決方案說明

## 🚨 問題分析

### 錯誤原因
```javascript
const [user, setUser] = useState() // ❌ 沒有初始值，user 為 undefined
```

當 `useState` 沒有提供初始值時，state 的值會是 `undefined`。後續嘗試：
- 存取 `user.name` → `undefined.name` → 錯誤
- 修改 `user.name = 'Jane'` → `undefined.name = 'Jane'` → 錯誤

## ✅ 解決方案

### 1. 提供適當初始值
```javascript
const [user, setUser] = useState(null) // ✅ 明確的初始值
```

### 2. 條件渲染
```javascript
if (loading) return <div>載入中...</div>
if (error) return <div>錯誤: {error}</div>
if (!user) return <div>沒有資料</div>
```

### 3. 防禦性編程
```javascript
const updateUserName = () => {
  if (user) { // ✅ 先檢查存在性
    setUser({...user, name: 'Jane Doe'})
  }
}
```

### 4. 正確的狀態更新
```javascript
// ❌ 錯誤：直接修改
user.name = 'Jane Doe'
setUser({...user})

// ✅ 正確：不可變更新
setUser({...user, name: 'Jane Doe'})
```

## 🎯 初始值選擇策略

| 初始值 | 適用情況 | 優缺點 |
|--------|----------|--------|
| `null` | 資料尚未載入 | ✅ 語義明確，需要條件渲染 |
| `{}` | 預期是物件 | ✅ 可直接存取屬性，但可能隱藏邏輯錯誤 |
| `預設結構` | 明確的資料結構 | ✅ 類型安全，❌ 可能與實際 API 不符 |

## 🏆 最佳實踐

1. **始終提供初始值** - 即使是 `null` 也比 `undefined` 好
2. **處理所有狀態** - 載入中、錯誤、成功、空資料
3. **防禦性編程** - 在存取前檢查物件存在性
4. **良好用戶體驗** - 提供載入指示器和錯誤處理
5. **類型一致性** - 確保狀態類型在整個生命週期保持一致
