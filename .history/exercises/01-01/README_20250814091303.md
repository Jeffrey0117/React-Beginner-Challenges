# 01-01 - Array.push 用在更新 state，居然不起作用了？

## 🎯 問題描述

點擊「新增 Kiki」按鈕後，為什麼畫面沒有出現變化呢？

## 🔴 問題程式碼

```jsx
const handleAddKiki = () => {
  users.push('Kiki')   // 直接修改原陣列
  setUsers(users)      // 傳入同一個陣列參考
}
```

**檔案位置：** [`problem/App.jsx`](problem/App.jsx)

## 🤔 思考問題

1. 為什麼直接修改陣列後，React 沒有重新渲染？
2. `users.push('Kiki')` 和 `setUsers(users)` 有什麼問題？
3. React 是如何判斷狀態是否改變的？
4. 什麼是「參考相等性」？

## � 測試步驟

1. 複製 `problem/App.jsx` 到主專案的 `src/App.jsx`
2. 點擊「新增 Kiki」按鈕
3. 觀察畫面是否有變化
4. 思考為什麼會這樣

## 💡 學習重點

- React 狀態更新機制
- JavaScript 參考型別 vs 原始型別
- 不可變性 (Immutability) 概念
- 陣列的淺比較

---

**完成思考後，請查看 [`solution/`](solution/) 資料夾的解答！**

#### 方法 1：展開運算符 (推薦)

```jsx
const handleAddKiki = () => {
  setUsers([...users, "Kiki"]); // 創建新陣列
};
```

#### 方法 2：使用 concat

```jsx
const handleAddKiki = () => {
  setUsers(users.concat("Kiki")); // concat 返回新陣列
};
```

#### 方法 3：防止重複新增

```jsx
const handleAddKiki = () => {
  if (!users.includes("Kiki")) {
    setUsers([...users, "Kiki"]);
  }
};
```

**檔案位置：** [`solution/App.jsx`](solution/App.jsx)

### 🧠 原理解釋

1. **參考相等性**：`users.push('Kiki')` 修改了原陣列，但陣列的記憶體位址沒有改變
2. **React 比較機制**：React 使用 `===` 來比較新舊 state
3. **結果**：React 認為沒有狀態變化，不會觸發重新渲染

### 📚 學習重點

- 不可變性 (Immutability)
- React 的淺比較
- ES6 展開運算符
- 陣列的 concat 方法

### 🚀 如何測試

1. 複製 `problem/App.jsx` 到主專案的 `src/App.jsx`
2. 點擊按鈕觀察沒有變化
3. 複製 `solution/App.jsx` 到主專案的 `src/App.jsx`
4. 點擊按鈕觀察正常工作
